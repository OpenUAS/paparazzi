<!DOCTYPE airframe SYSTEM "../airframe.dtd">
<airframe name="ARDrone2">
  <description>
  A slightly modified Parrot AR.Drone 2.0 (http://www.openuas.org/aircraft/)
  A good airframe to validate all onboard functionally...
  Parrot AR.Drone 2.0
    + Autopilot:   Default
    + IMU:         Default
    + Motors:      Default Motors
    + Actuators:   Default ESC
    + GPS:         Added uBlox LEA5H and Sarantel helix GPS antenna
    + CURRENT:     Default build in V/A sensing
    + AGL ranging: Default sonar

  NOTES:
    + Plz calibrate your magnetometer, Yes, you too ;), unit UKF auto works...
    + And callibrate your Accelometer also...
    + Original brass ballbearings replaced with real ball bearings for all shafts
    + Frontcamera movable by servo on debug port - optional
    + OpenRX RXSR on debug port - optional
    + Flies on INDI control

    + To testfly this airframe yourself you need to:
    ++ point to your own calibrations xml, search for 'calibration' in this document

  WIP:
    + Not all gains are tuned to optimum, feel free to enhance and a PR...
    + Range sensor needs to be put to good use
    + SD SRTM via onboard storage not implemented (yet..)
  </description>
  <firmware name="rotorcraft">
    <target name="ap" board="ardrone2">
      <!--
      <define name="AHRS_ALIGNER_SAMPLES_NB" value="600"/>
      <define name="LOW_NOISE_THRESHOLD" value="30000"/>
      <define name="LOW_NOISE_TIME" value="10"/>
      -->

      <define name="AUTOPILOT_DISABLE_AHRS_KILL"/>

      <!--<define name="USE_PERSISTENT_SETTINGS" value="TRUE"/>-->
      <define name="BAT_CHECKER_DELAY" value="50"/>
      <!-- amount of time it take for the bat to check -->
      <!-- to avoid bat low spike detection when strong up movement withch draws short sudden power-->
      <define name="CATASTROPHIC_BATTERY_KILL_DELAY" value="50"/><!-- in seconds-->
    </target>

    <target name="nps" board="pc">
      <module name="fdm" type="jsbsim"/>
      <module name="udp"/>
      <!-- INDI RPM feedback not implemented in sim, will it be YOU who adds this? TIA! -->
      <module name="stabilization" type="indi">
        <define name="INDI_RPM_FEEDBACK" value="FALSE"/>
      </module>
      <!--<module name="uart"/>--><!-- TODO: Exteral HITL PC debugging e.g test external device triggering while mission flying in sim -->
      <define name="STABILIZATION_INDI_G2_R" value="0.0"/><!-- for jsbsim (rotor inertia is not modelled) -->
      <!-- <define name="STABILIZATION_INDI_G2_R" value="0.20"/> --><!-- If one wants to use Gazebo sim -->
      <!--<module name="uart"/>--><!-- TODO: Exteral HITL PC debugging e.g test external device triggering while mission flying in sim -->
    </target>

    <define name="WIND_INFO"/>
    <define name="WIND_INFO_RET"/>

    <!--<define name="USE_PERSISTENT_SETTINGS" value="TRUE"/>--><!-- TODO test on Busybox -->

    <!-- amount of time it take for the bat to trigger check -->
    <!-- to avoid bat low spike detection when strong pullup withch draws short sudden power-->
    <!-- TODO: specificaly test for Disco see if needed or which value -->
    <define name="BAT_CHECKER_DELAY" value="60"/><!-- unit="s/10", thus tenth of seconds per default use ELECTRICAL_PERIODIC_FREQ if you for some reason want it differently-->
    <!-- Only one main battery so CATASTROPHIC_BATTERY kill should be somewhat delayed -->
    <define name="CATASTROPHIC_BATTERY_KILL_DELAY" value="410"/> <!-- unit="s/10, thus  tenth of seconds for engine kill or in ELECTRICAL_PERIODIC_FREQ-->
    <define name="AUTOPILOT_DISABLE_AHRS_KILL"/>
    <configure name="AHRS_MAG_CORRECT_FREQUENCY" value="50"/><!-- HZ-->
    <configure name="USE_BARO_BOARD" value="TRUE"/>

    <!-- USE_SONAR means the device can read values. It does not mean we want to use those values in AHRS yet
    For that you have a setting <define name="AHRS_USE_SONAR" value="TRUE"/>
    Since sometimes you want to just read sonar values to scan an area surface height difference but not do
    anything with it AGL in control -->
    <define name="USE_SONAR" value="TRUE"/>

    <define name="AHRS_USE_SONAR" value="TRUE"/>
    <define name="SENSOR_SYNC_SEND_SONAR"/><!-- Enable if you want it debug sonar device, eg raw values -->

    <configure name="USE_MAGNETOMETER" value="TRUE"/> <!-- Make sure is callibrated, and to set false.. Hmm better have your Visionbased solution working ;) -->

    <!-- Subsystem section -->
    <module name="telemetry" type="transparent_udp"/>
    <module name="radio_control" type="datalink"/>
    <module name="motor_mixing"/>
    <module name="actuators" type="ardrone2"/>
    <module name="imu" type="ardrone2"/>
    <module name="gps" type="ublox"/>

    <!-- A default NMEA GPS could theoretically be used never tested oneself, not sure if it works -->
    <!--<module name="gps" type="nmea"/>-->

     <!-- For testing original orange Parrot GPS dongel make sure that you user sirftool to sert it up and then enable this-->
     <!-- <module name="gps" type="sirf">-->

      <!--<configure name="UART2_DEV" value="UART2"/>-->
      <!--<configure name="GPS_PORT" value="UART2_DEV"/>-->
    <!--   <configure name="GPS_BAUD" value="B57600"/>-->
    <!-- </module> -->

    <module name="stabilization" type="indi"/><!-- Full INDI with prio -->
     <!--<define name="INDI_RPM_FEEDBACK" value="TRUE"/>-->
    </module>
    <!--<module name="stabilization" type="indi_simple"/>-->

    <module name="ahrs" type="float_cmpl_quat">
      <define name="AHRS_USE_GPS_HEADING" value="TRUE"/>
      <!--<configure name="USE_MAGNETOMETER" value="TRUE"/>--><!-- if using INS EKF2 this forced already-->
      <configure name="AHRS_USE_MAGNETOMETER" value="TRUE"/>
      <define name="AHRS_MAG_UPDATE_ALL_AXES" value="FALSE"/>
      <!-- <define name="AHRS_GPS_SPEED_IN_NEGATIVE_Z_DIRECTION" value="FALSE"/>-->
      <define name="AHRS_HEADING_UPDATE_GPS_MIN_SPEED" value="3.0" unit="m/s"/>
      <define name="AHRS_GRAVITY_HEURISTIC_FACTOR" value="5.0"/>
    </module>

    <module name="ins" type="ekf2"/>
  </firmware>

  <modules main_freq="512">
    <module name="bat_voltage_ardrone2"/>
    <module name="gps" type="ubx_ucenter"/>
    <module name="send_imu_mag_current"/>
    <module name="air_data"/>
     <!-- ************************* PHOTOGRAMMETRY ****************************** -->
     <!-- <module name="photogrammetry_calculator"/> -->
    <!--<module name="video_rtp_stream">
      <define name="VIEWVIDEO_QUALITY_FACTOR" value="75"/>
      <define name="VIEWVIDEO_FPS" value="4"/>
      <define name="VIEWVIDEO_SHOT_PATH" value="/data/video/usb0/myphotos"/>
    </module>-->
    <!--<module name="video_usb_logger"/>
      <define name="LOG_ON_USB" value="TRUE"/>
      <define name="VIDEO_USB_LOGGER_PATH" value="/data/video/usb0/myphotologs"/>
    </module>-->
    <module name="logger_file">
      <!--<define name="FILE_LOGGER_PATH" value=""/>-->
    </module>

    <!-- can be used in flightplan during takeoff/landing or lowflyby with default sonar -->
    <module name="agl_dist">
        <!-- Make sure something like this is defined <define name="USE_SONAR"/>-->
    </module>

    <!-- Have some fun with the camera -->
    <module name="cv_colorfilter">
      <define name="COLORFILTER_CAMERA" value="front_camera"/>
    </module>

    <module name="orange_avoider" />

    <module name="video_rtp_stream">
      <define name="VIEWVIDEO_CAMERA" value="front_camera"/>
      <define name="VIEWVIDEO_DOWNSIZE_FACTOR" value="4"/>
      <define name="VIEWVIDEO_QUALITY_FACTOR" value="60"/>
    </module>
  </modules>

      <module name="digital_cam_video">
      <define name="DC_AUTOSHOOT_DISTANCE_INTERVAL" value="5.0"/> <!-- unit="s"/> -->
    </module>

    <!-- When flying multiple airframes over eg a mesh they can have info of eachothers position etc. -->
    <module name="traffic_info">
    </module>
<!--
    <module name="tcas">
    </module>
-->
  <module name="sys_mon"/><!-- for MCU load debugging -->


  <!-- ************************ AUTO RC COMMANDS ***************************** -->
  <auto_rc_commands>
    <!-- To still be able to trigger cam in MODENAV-->
    <!-- <set command="SHOOT" value="@AUX1"/> -->
  </auto_rc_commands>
<!-- ************************ COMMANDS ***************************** -->
  <commands>
    <axis name="PITCH" failsafe_value="0"/>
    <axis name="ROLL" failsafe_value="0"/>
    <axis name="YAW" failsafe_value="0"/>
    <axis name="THRUST" failsafe_value="3000"/>
  </commands>

  <servos driver="Default">
    <servo name="TOP_LEFT" no="0" min="0" neutral="1" max="500"/>
    <servo name="TOP_RIGHT" no="1" min="0" neutral="1" max="500"/>
    <servo name="BOTTOM_RIGHT" no="2" min="0" neutral="1" max="500"/>
    <servo name="BOTTOM_LEFT" no="3" min="0" neutral="1" max="500"/>
  </servos>

  <section name="MIXING" prefix="MOTOR_MIXING_">
    <define name="TRIM_ROLL" value="0"/>
    <define name="TRIM_PITCH" value="0"/>
    <define name="TRIM_YAW" value="0"/>

    <!-- Time cross layout (X), with order NW (CW), NE (CCW), SE (CW), SW (CCW) -->
    <define name="TYPE" value="QUAD_X"/>
  </section>

  <command_laws>
    <call fun="motor_mixing_run(autopilot_get_motors_on(),FALSE,values)"/>
    <set servo="TOP_LEFT" value="motor_mixing.commands[MOTOR_FRONT_LEFT]"/>
    <set servo="TOP_RIGHT" value="motor_mixing.commands[MOTOR_FRONT_RIGHT]"/>
    <set servo="BOTTOM_RIGHT" value="motor_mixing.commands[MOTOR_BACK_RIGHT]"/>
    <set servo="BOTTOM_LEFT" value="motor_mixing.commands[MOTOR_BACK_LEFT]"/>
  </command_laws>

<!-- ************************* IMU ************************* -->
  <section name="IMU" prefix="IMU_">
    <!-- Accelero -->
    <define name="ACCEL_X_NEUTRAL" value="2048"/>
    <define name="ACCEL_Y_NEUTRAL" value="2048"/>
    <define name="ACCEL_Z_NEUTRAL" value="2048"/>

<!--
Calibrating the Magnetometer

First of all it is important to know that all ferromagnetic materials near the mag distort the measurements.
So preferably you do the mag calibration with the mag/autopilot mounted in your frame and as far away from metal and magnets as possible.
Calibrating for the Earth magnetic field

The most crucial part for the magnetometer calibration:

1) Stop Server, start server, creates new log file we need for calibration
2) Slowly spin your aircraft around all axes round a minute or so...
3) Stop the server so it will write the log file
4) Run a Calibartion calculation script to get your calibration coefficients:

 sw/tools/calibration/calibrate.py -s MAG var/logs/YY_MM_DD__hh_mm_ss.data -vp

 ( Where YY_MM_DD__hh_mm_ss.data is the name of the log data file that was just generated.)

5) Paste the results below (CTRL+SHIFT+C to copy form terminal) overwriteing
6) Save this file, then in PPRZ center: clean, build and upload to aircraft... Done!
-->

    <!-- ***************** MAGNETO ********************************-->
      <!-- Magnetometer still needs to be calibrated -->
    <define name="MAG_X_NEUTRAL" value="-16"/>
    <define name="MAG_Y_NEUTRAL" value="55"/>
    <define name="MAG_Z_NEUTRAL" value="204"/>
    <define name="MAG_X_SENS" value="7.28514789391" integer="16"/>
    <define name="MAG_Y_SENS" value="7.33022132691" integer="16"/>
    <define name="MAG_Z_SENS" value="7.57102035692" integer="16"/>

    <!--define name="MAG_OFFSET" value="-?.0" unit="deg"--> <!--  TODO: at least 3 axis in worst case -->

    <!-- Magneto current calibration TODO:
    Best done outside, set it to RC direct and throttle up and down with raw messages -->
    <define name="MAG_X_CURRENT_COEF" value="0.0"/>
    <define name="MAG_Y_CURRENT_COEF" value="0.0"/>
    <define name="MAG_Z_CURRENT_COEF" value="0.0"/>

    <!-- most likly OK with an physically unmodified airframe -->
    <define name="BODY_TO_IMU_PHI" value="0." unit="deg"/>
    <define name="BODY_TO_IMU_THETA" value="0." unit="deg"/>
    <define name="BODY_TO_IMU_PSI" value="0." unit="deg"/>
  </section>

  <!-- local magnetic field -->
  <!-- http://wiki.paparazziuav.org/wiki/Subsystem/ahrs#Local_Magnetic_Field -->

  <!-- local magnetic field -->
  <!-- http://wiki.paparazziuav.org/wiki/Subsystem/ahrs#Local_Magnetic_Field -->
  <section name="AHRS" prefix="AHRS_">
    <!-- values used if no GPS fix, on 3D fix is update by geo_mag module -->
    <!-- <define name="HEADING_UPDATE_GPS_MIN_SPEED" value="0"/>--> <!-- only for Optitrack -->
    <!-- Local Magnetic field NL2019 ZH -->
    <!--
     <define name="H_X" value="0.382478"/>
     <define name="H_Y" value="0.00563406"/>
     <define name="H_Z" value="0.923948"/>
     -->

    <!-- Local Magnetic field DE2019 RP -->
    <define name="H_X" value="0.38644"/>
    <define name="H_Y" value="0.02054"/>
    <define name="H_Z" value="0.92209"/>
  </section>


  <!-- *************************** SONAR DEVICE ***************************** -->
  <section name="SONAR" prefix="SONAR_">
    <define name="SCALE" value="0.016775" integer="16"/>
    <define name="OFFSET" value="0.03" unit="m"/><!-- The landing gear height to tarmac, well ~0 m with this flyingwing -->
    <define name="MAX_RANGE" value="1.7" unit="m"/>
    <define name="MIN_RANGE" value="0.18" unit="m"/>
  </section>

  <!-- *************************** AGL **************************** -->
  <section name="AGL" prefix="AGL_DIST_SONAR_">
    <define name="ID" value="ABI_BROADCAST"/>
    <define name="MAX_RANGE" value="1.5" unit="m"/>
    <define name="MIN_RANGE" value="0.018" unit="m"/>
    <define name="FILTER" value="0.15"/> <!--Low pass filter time constant-->
  </section>

  <!-- ************************ MAG_CALIB_UKF ************************ -->
<!-- HOTSTART TRUE for faster convergence flights to flight -->
<!-- <define name="HOTSTART_SAVE_FILE" value="/data/ftp/internal_000/mag_ukf_calib.txt"/>-->
  <section name="MAG_CALIB_UKF" prefix="MAG_CALIB_UKF_">
    <define name="HOTSTART" value="FALSE"/>
    <define name="HOTSTART_SAVE_FILE" value="/data/ftp/internal_000/mag_ukf_calib.txt"/>
    <define name="NORM" value="1.0f"/>
    <define name="NOISE_RMS" value="5e-2f"/>
    <define name="GEO_MAG_TIMEOUT" value="0"/>
    <define name="INITIAL_STATE" value="0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0" type="float[]"/>
    <define name="VERBOSE" value="FALSE"/><!-- Disable after testing -->
  </section>


  <section name="INS" prefix="INS_">
    <!-- For those super precice target landings... well better swap the M8N GNSS for a M8P or M9P -->
    <define name="BODY_TO_GPS_X" value="0.08" unit="m"/>
    <define name="BODY_TO_GPS_Y" value="0.0" unit="m"/>
    <define name="BODY_TO_GPS_Z" value="0.07" unit="m"/>

    <!-- <define name="USE_INS_MODULE"/> -->
    <define name="ROLL_NEUTRAL_DEFAULT" value="0." unit="deg"/>
    <define name="PITCH_NEUTRAL_DEFAULT" value="0." unit="deg"/>

    <define name="SONAR_COMPENSATE_ROTATION" value="TRUE"/><!-- compensate AGL for body rotation -->
    <define name="SONAR_UPDATE_ON_AGL" value="TRUE"/>

    <define name="USE_GPS_ALT" value="1"/>
    <define name="USE_GPS_ALT_SPEED" value="1"/>
    <define name="VFF_R_GPS" value="0.01"/>
  </section>

  <section name="RC_SETPOINT" prefix="STABILIZATION_ATTITUDE_">
    <!-- setpoint limits for attitude stabilization rc flight -->
    <define name="SP_MAX_PHI" value="40" unit="deg"/>
    <define name="SP_MAX_THETA" value="40" unit="deg"/>
    <define name="SP_MAX_R" value="130" unit="deg/s"/>
    <define name="DEADBAND_A" value="10"/>
    <define name="DEADBAND_E" value="10"/>
    <define name="DEADBAND_R" value="200"/>
  </section>

  <section name="ATTITUDE_REFERENCE" prefix="STABILIZATION_ATTITUDE_">
    <!-- attitude reference generation model -->
    <define name="REF_OMEGA_P" value="450" unit="deg/s"/>
    <define name="REF_ZETA_P" value="0.9"/>
    <define name="REF_MAX_P" value="600." unit="deg/s"/>
    <define name="REF_MAX_PDOT" value="RadOfDeg(8000.)"/>

    <define name="REF_OMEGA_Q" value="450" unit="deg/s"/>
    <define name="REF_ZETA_Q" value="0.9"/>
    <define name="REF_MAX_Q" value="600." unit="deg/s"/>
    <define name="REF_MAX_QDOT" value="RadOfDeg(8000.)"/>

    <define name="REF_OMEGA_R" value="450" unit="deg/s"/>
    <define name="REF_ZETA_R" value="0.9"/>
    <define name="REF_MAX_R" value="600." unit="deg/s"/>
    <define name="REF_MAX_RDOT" value="RadOfDeg(8000.)"/>
  </section>

  <section name="STABILIZATION_ATTITUDE_INDI" prefix="STABILIZATION_INDI_">
    <!-- control effectiveness -->
    <define name="G1_P" value="0.032"/>
    <define name="G1_Q" value="0.025"/>
    <define name="G1_R" value="0.0032"/>
    <define name="G2_R" value="0.16"/>

    <!-- reference acceleration for attitude control -->
    <define name="REF_ERR_P" value="380.0"/>
    <define name="REF_ERR_Q" value="380.0"/>
    <define name="REF_ERR_R" value="250.0"/>
    <define name="REF_RATE_P" value="21.6"/>
    <define name="REF_RATE_Q" value="21.6"/>
    <define name="REF_RATE_R" value="21.0"/>

    <!-- second order filter parameters -->
    <define name="FILT_CUTOFF" value="3.2"/>
    <define name="FILT_CUTOFF_R" value="3.2"/>

    <!-- first order actuator dynamics -->
    <define name="ACT_DYN_P" value="0.06"/>
    <define name="ACT_DYN_Q" value="0.06"/>
    <define name="ACT_DYN_R" value="0.06"/>

    <!-- Adaptive Learning Rate -->
    <define name="USE_ADAPTIVE" value="FALSE"/>
    <define name="ADAPTIVE_MU" value="0.0001"/>
  </section>

  <section name="GUIDANCE_V" prefix="GUIDANCE_V_">
    <define name="HOVER_KP" value="283"/>
    <define name="HOVER_KD" value="82"/>
    <define name="HOVER_KI" value="13"/>
    <define name="NOMINAL_HOVER_THROTTLE" value="0.655"/>
    <define name="ADAPT_THROTTLE_ENABLED" value="FALSE"/>
  </section>

  <section name="GUIDANCE_H" prefix="GUIDANCE_H_">
    <!-- Good weather -->
    <define name="MAX_BANK" value="20" unit="deg"/>
    <!-- Bad weather -->
    <!-- define name="MAX_BANK" value="32" unit="deg"/ -->
    <define name="PGAIN" value="79"/>
    <define name="DGAIN" value="100"/>
    <define name="IGAIN" value="30"/>
  </section>

  <section name="MISC">
    <define name="ARRIVED_AT_WAYPOINT" value="4.0" unit="m"/> <!-- To set how far away you find OK that drone thnks the waypoint is reached -->
    <define name="KILL_MODE_DISTANCE" value="MAX_DIST_FROM_HOME*1.1+HOME_RADIUS" unit="m"/>  <!--  improve value by default turn radius calc -->
    <define name="DEFAULT_CIRCLE_RADIUS" value="5." unit="m"/><!-- for if you want to.... circle ;) -->
    <define name="CARROT" value="4." unit="s"/>
    <!-- UNLOCKED_HOME_MODE if set to TRUE means that HOME mode does not get stuck.
    If not set before when you would enter home mode you had to flip a bit via the GCS to get out. -->
    <define name="UNLOCKED_HOME_MODE" value="TRUE"/>
    <!-- RC_LOST_MODE means that if your RC Transmitter signal is not received anymore in the autopilot, e.g. you switch it off
    or  fly a long range mission you define the wanted mode behaviour here.
    If you do not define it, it defaults to flying to the flightplan HOME -->
    <define name="AP_MODE_AUTO2" value="MODE_AUTO2"/>
    <define name="RC_LOST_MODE" value="AP_MODE_AUTO2"/>

    <!-- TODO: SET some modem values with multipoint also the $AC_ID -->
    <!--  Here XBEE init will be misused to set SiK Si10xx based modems as the Hope and RFdesign -->
    <!--  <define name="XBEE_INIT" value="ATS17=$AC_ID\rATS16=134\rAT&W\rATZ\r" type="string"/>  -->
    <!--  <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
  </section>

  <section name="NAVIGATION" prefix="NAV_">
    <define name="CLIMB_VSPEED" value="2.5"/>
    <define name="DESCEND_VSPEED" value="-1.0"/>
  </section>

  <section name="AUTOPILOT">
    <define name="MODE_STARTUP" value="AP_MODE_NAV"/>
    <define name="MODE_MANUAL" value="AP_MODE_ATTITUDE_DIRECT"/>
    <define name="MODE_AUTO1" value="AP_MODE_ATTITUDE_Z_HOLD"/>
    <define name="MODE_AUTO2" value="AP_MODE_NAV"/>
    <define name="NO_RC_THRUST_LIMIT" value="TRUE"/>
  </section>

  <!-- **************************** BAT ****************************** -->
  <section name="BAT">
    <define name="MAX_BAT_CAPACITY" value="1200" unit="mAh"/> <!-- Original Parrot battery -->
    <define name="MILLIAMP_AT_FULL_THROTTLE" value="8700" unit="mA"/>
    <define name="MILLIAMP_AT_IDLE_THROTTLE" value="400" unit="mA"/>
    <define name="CURRENT_ESTIMATION_NONLINEARITY" value="1.0"/>
    <define name="MAX_BAT_LEVEL" value="12.6" unit="V"/> <!-- 3S lipo 3x4.2 = 12.6 -->
    <define name="LOW_BAT_LEVEL" value="10.4" unit="V"/>
    <define name="CRITIC_BAT_LEVEL" value="9.6" unit="V"/>
    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/> <!-- TODO: test when AP board switches off -->
    <define name="MIN_BAT_LEVEL" value="9.0" unit="V"/>
  </section>


  <!-- ********************** GCS SPECIFICS ************************** -->
  <section name="GCS">
    <define name="SPEECH_NAME" value="A R drone Two"/>
    <define name="ALT_SHIFT_PLUS_PLUS" value="5"/>
    <define name="ALT_SHIFT_PLUS"      value="1"/>
    <define name="ALT_SHIFT_MINUS"     value="-1"/>
    <define name="AC_ICON"             value="quadrotor_x"/>
  </section>
  </section>

  <!-- ************************ NPSSIM ******************************* -->
  <section name="SIMULATOR" prefix="NPS_">
    <define name="ACTUATOR_NAMES" value="nw_motor, ne_motor, se_motor, sw_motor" type="string[]"/>
    <define name="JSBSIM_MODEL" value="simple_ardrone2" type="string"/>
    <define name="JSBSIM_INIT" value="reset00" type="string"/>
    <define name="SENSORS_PARAMS" value="nps_sensors_params_ardrone2.h" type="string"/>
  </section>

</airframe>
